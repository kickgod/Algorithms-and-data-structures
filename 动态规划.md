动态规划
----
> `基本思想`: `自底向上,填表查表技术`<br/>
* `多阶段决策过程.每步求解的问题是后面阶段求解问题的子问题. 每步决策将依赖于以前步骤的决策结果.`
* `掌握动态规划算法的基本要素` 
  * 1.最优子结构性质: `如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质(即满足最优化原理）`
  * 2.重叠子问题性质：`在用递归算法自顶向下解此问题时,每次产生的子问题并不总是新问题,有些子问题被反复计算多次`
----
#### 题例---`动态规范`
-----
#### 1.矩阵链相乘
-----
题目:给定n个矩阵｛A1,A2,…,An｝，其中Ai与Ai+1是可乘的，i=1,2 ,…,n-1。如何确定计算矩阵连乘积的计算次序，使得依此次序计算矩阵连乘积需要的数乘次数最少
```java

int[][] PlaceStore;
int[][] result;

public MatrixMultiplication(int[] maxtixCR){ 
	this.MatixCR=maxtixCR;		
	MatrixCount=maxtixCR.length-1;
	PlaceStore =new int[maxtixCR.length][maxtixCR.length];
	result =new int[maxtixCR.length][maxtixCR.length];
}

private int  recurMatrixChain(int []p,int i,int j){
	 if(i==j) return 0;
	 result[i][j]=Integer.MAX_VALUE;
	 PlaceStore[i][j]=i;
	 int temp;
	 for(int k=i;k<j;k++) {
		 temp=recurMatrixChain(p,i,k)+recurMatrixChain(p,k+1,j)+p[i-1]*p[k]*p[j];
		 if(temp<result[i][j]) {
			 result[i][j]=temp;
			 PlaceStore[i][j]=k;
		 }
	 }
	 return result[i][j];
 }
```
#### 2.投资问题
-----
特性：
* 复杂度:O(nm平方)
#### 3.01背包问题
---
题目:有n 个物品，它们有各自的重量和价值，现有给定容量的背包，如何让背包里装入的物品具有最大的价值总和？

``` java
public class BackpackProblem {
	private int numberofthestuffs; 	//物品种类
	private int BackpackWeight;    	//背包重量
	private int[] weighti;
	private int[] valuei;
	private int[] result;
	int[][] MaxValue;
	
	public BackpackProblem(int BackpackWeight,int stuffCount,int[] weighti,int[] valuei) {
			this.weighti=weighti;
			this.valuei=valuei;
			this.numberofthestuffs=stuffCount;
			this.BackpackWeight=BackpackWeight;
			result=new int[stuffCount+1];
			MaxValue=new int[stuffCount+1][BackpackWeight+1];
			getResult();
	}
	public void printResult() {
		for(int typeCount=0;typeCount<=this.numberofthestuffs;typeCount++) {
			for(int weight=0;weight<=this.BackpackWeight;weight++) {
					System.out.print( MaxValue[typeCount][weight]+"   ");
			}
			System.out.println();
		}
		System.out.print("答案为: ");
		for(int i=0;i<numberofthestuffs+1;i++) System.out.print(result[i]+"");
	}
	
	private void detailresult() {
		int n=numberofthestuffs;
		int wei=BackpackWeight;
		while(n>0) {
			if(MaxValue[n][wei]==MaxValue[n-1][wei]) {
				result[n]=0;
				n=n-1;
			}else {
				result[n]=1;
				wei=wei-weighti[n];
				n=n-1;
			}
		}
	}
		
	/**
	 * 动态规划办法
	 */
	private void  getResult() {
		for(int i=0;i<=this.numberofthestuffs;i++) MaxValue[i][0]=0;
		for(int i=0;i<=this.BackpackWeight;i++) MaxValue[0][i]=0;
		result[0]=0;

		for(int typeCount=1;typeCount<=this.numberofthestuffs;typeCount++) {
			for(int weight=1;weight<=this.BackpackWeight;weight++) {
				if(weight>=weighti[typeCount]) {
					MaxValue[typeCount][weight]=Math.max(MaxValue[typeCount-1][weight], MaxValue[typeCount][weight-weighti[typeCount]]+valuei[typeCount]);	
				}else {
					MaxValue[typeCount][weight]=MaxValue[typeCount-1][weight];
				}
			}
		}
		detailresult();
	}
}
```
