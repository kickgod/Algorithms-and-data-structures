分治法
---
> `定义`: `将一个难以直接解决的大问题，合理分割成一些规模较小的相同问题，以便各个击破，这个策略就叫分而治之`<br/>
---
> 直接或间接地调用自身的算法称为递归算法。 用函数自身给出定义的函数称为递归函数 分治与递归像一对孪生兄弟，经常同时应用在 算法设计之中，并由此产生许多高效算法。<br/>

---
最优子结构性质:`如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）`

平衡子问题:`种使子问题规模大致相等的做法是出自一种平衡 (balancing)子问题的思想`


#### 分治法的两个启发式规则: `独立子问题`,`平衡子问题`
#### 递归函数的两个要素
    * 边界条件
    * 递归方程
#### 分治策略
* 1.**分解**: `将原始问题划分或者归结为规模较小的自问题`  <br/>
* 2.**求解**:`迭代或递归求解每一个自问题`<br/>
* 3.**合并**:`将子问题的解综合得到原问题的解`<br/>
#### 注意原则
* 1.`子问题和原问题性质完全一样`
* 2.`子问题之间可以彼此独立地求解`
* 3.`递归停止子问题可直接求解`
* 4.`在用分治法设计算法时， 最好使子问题的规模大致相同`
----
**分治法**可以分为两个重要步骤：<br/>
* `自顶向下`：将问题不断分割成小的问题
* `自底而上`：将小问题解决来构建大问题的解。
### 例如
#### 阶梯问题
一个阶梯有n个级，一个人要走完这个阶梯，一步可以走一级或两级。问：共有多少个方案？
> 本质上就是斐波拉基数列<br/>
`一个台阶 只有一种走法`<br/>
`两个台阶 有两种走法  走两步 走一步`<br/>
`三个台阶 可以是从第二个台阶走一步跨两级 也可以是从第一个台阶走两步一步一级 所有为第一层的走法加上到第二层的走法`<br/>
`四个个台阶 可以是从第二个台阶走一步跨两级 也可以是从第一个台阶走两步 所有为第二层的走法加上到第三层的走法`<br/>
...  `类推`<br/>
`斐波那契数列,每次只能走1或2级，所以到第十层的走法总和是到第8层的走法加上到第9层的走法`<br/>
#### C语言代码
```c
int step(int s)
{
    if( s <= 0 )
        return 0;
    if( s <= 2 )
        return s;
    return step( s - 1 ) + step( s - 2 );
}
```

#### 二路归并排序 
> `二路归并排序是采用的分而治之的思想。将一个待排序的序列分成两个序列，分别对这两个序列排序。而对于这两个序列排序的方式也是还之前一
样，将这两个序列分别分成两个序列分别排序。一直这样分割下去，知道序列中没有元素或者已有一个元素为止。因为没有元素的序列和只有一个
元素的序列定是一个有序的序列，所以相当于将这个序列排序完毕，向上返回。返回的过程中做的最重要的一件事就是将两个有序的序列合并成一
个有序的序列。`

二路归并排序的最好,最坏,和平均时间复杂度为`O(nlgn)`;是一种稳定的排序 <br/>

#### C#代码

``` C#
public static void Sort(int[] a, int f, int e)
{
    if (f < e)
    {
        int mid = (f + e) / 2;
        Sort(a, f, mid);
        Sort(a, mid + 1, e);
        MergeMethid(a, f, mid, e);
    }
}
```

``` c#
private static void MergeMethid(int[] a, int f, int mid, int e)
{
    int[] t = new int[e - f + 1];
    int m = f, n = mid + 1, k = 0;
    while(n <= e && m <= mid)
    {
        if (a[m] > a[n]) t[k++] = a[n++];
        else t[k++] = a[m++];
    }
    while (n < e + 1) t[k++] = a[n++];
    while (m < mid + 1) t[k++] = a[m++];
    for (k = 0, m = f; m < e + 1; k++, m++) a[m] = t[k];
}
```
参考: [`其他语言代码`](https://baike.baidu.com/item/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/1639015?fr=aladdin)
#### 快速排序 
> `快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。`
``` c
void sort(int *a, int left, int right)
{
    if(left >= right)/*如果左边索引大于或者等于右边的索引就代表已经整理完成一个组了*/
    {
        return ;
    }
    int i = left;
    int j = right;
    int key = a[left];
     
    while(i < j)                               /*控制在当组内寻找一遍*/
    {
        while(i < j && key <= a[j])
        /*而寻找结束的条件就是，1，找到一个小于或者大于key的数（大于或小于取决于你想升序还是降序）2，没有符合条件1的，并且i与j的大小没有反转*/ 
        {
            j--;/*向前寻找*/
        }
         
        a[i] = a[j];
        /*找到一个这样的数后就把它赋给前面的被拿走的i的值（如果第一次循环且key是
        a[left]，那么就是给key）*/
         
        while(i < j && key >= a[i])
        /*这是i在当组内向前寻找，同上，不过注意与key的大小关系停止循环和上面相反，因为排序思想是把数往两边扔，所以左右两边的数大小与key的关系相反*/
        {
            i++;
        }
        a[j] = a[i];
    }
    a[i] = key;/*当在当组内找完一遍以后就把中间数key回归*/
    sort(a, left, i - 1);/*最后用同样的方式对分出来的左边的小组进行同上的做法*/
    sort(a, i + 1, right);/*用同样的方式对分出来的右边的小组进行同上的做法*/
                       /*当然最后可能会出现很多分左右，直到每一组的i = j 为止*/
}
```
#### 适用条件
* 该问题缩小到一定程度就可以容易地解决
* 该问题可以分解成若干个规模较小的相同问题,即该问题具有最优子结构性质
* 子问题的解可以合并为该问题的解
* 子问题的求解相互独立
