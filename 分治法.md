分治法
---
> `定义`: `将一个难以直接解决的大问题，合理分割成一些规模较小的相同问题，以便各个击破，再将求出的小规模的问题的解合并为一个更大规模的问题的解，自底向上逐步求出原来问题的解这个策略就叫分而治之`<br/>
---
> 介绍:`在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……`
#### 分治策略
* 1.`将原始问题划分或者归结为规模较小的自问题`<br/>
* 2.`迭代或递归求解每一个自问题`<br/>
* 3.`将子问题的解综合得到原问题的解`<br/>
#### 注意原则
* 1.`子问题和原问题性质完全一样`
* 2.`子问题之间可以彼此独立地求解`
* 3.`递归停止子问题可直接求解`
----
**分治法**可以分为两个重要步骤：<br/>
* `自顶向下`：将问题不断分割成小的问题
* `自底而上`：将小问题解决来构建大问题的解。
### 例如
#### 二路归并排序 
> `二路归并排序是采用的分而治之的思想。将一个待排序的序列分成两个序列，分别对这两个序列排序。而对于这两个序列排序的方式也是还之前一
样，将这两个序列分别分成两个序列分别排序。一直这样分割下去，知道序列中没有元素或者已有一个元素为止。因为没有元素的序列和只有一个
元素的序列定是一个有序的序列，所以相当于将这个序列排序完毕，向上返回。返回的过程中做的最重要的一件事就是将两个有序的序列合并成一
个有序的序列。`

二路归并排序的最好,最坏,和平均时间复杂度为`O(nlgn)`;是一种稳定的排序 <br/>

#### C#代码

``` C#
public static void Sort(int[] a, int f, int e)
{
    if (f < e)
    {
        int mid = (f + e) / 2;
        Sort(a, f, mid);
        Sort(a, mid + 1, e);
        MergeMethid(a, f, mid, e);
    }
}
```

``` c#
private static void MergeMethid(int[] a, int f, int mid, int e)
{
    int[] t = new int[e - f + 1];
    int m = f, n = mid + 1, k = 0;
    while(n <= e && m <= mid)
    {
        if (a[m] > a[n]) t[k++] = a[n++];
        else t[k++] = a[m++];
    }
    while (n < e + 1) t[k++] = a[n++];
    while (m < mid + 1) t[k++] = a[m++];
    for (k = 0, m = f; m < e + 1; k++, m++) a[m] = t[k];
}
```
参考: [`其他语言代码`](https://baike.baidu.com/item/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/1639015?fr=aladdin)
#### 快速排序 
> `快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。`
``` c
void sort(int *a, int left, int right)
{
    if(left >= right)/*如果左边索引大于或者等于右边的索引就代表已经整理完成一个组了*/
    {
        return ;
    }
    int i = left;
    int j = right;
    int key = a[left];
     
    while(i < j)                               /*控制在当组内寻找一遍*/
    {
        while(i < j && key <= a[j])
        /*而寻找结束的条件就是，1，找到一个小于或者大于key的数（大于或小于取决于你想升序还是降序）2，没有符合条件1的，并且i与j的大小没有反转*/ 
        {
            j--;/*向前寻找*/
        }
         
        a[i] = a[j];
        /*找到一个这样的数后就把它赋给前面的被拿走的i的值（如果第一次循环且key是
        a[left]，那么就是给key）*/
         
        while(i < j && key >= a[i])
        /*这是i在当组内向前寻找，同上，不过注意与key的大小关系停止循环和上面相反，因为排序思想是把数往两边扔，所以左右两边的数大小与key的关系相反*/
        {
            i++;
        }
        a[j] = a[i];
    }
    a[i] = key;/*当在当组内找完一遍以后就把中间数key回归*/
    sort(a, left, i - 1);/*最后用同样的方式对分出来的左边的小组进行同上的做法*/
    sort(a, i + 1, right);/*用同样的方式对分出来的右边的小组进行同上的做法*/
                       /*当然最后可能会出现很多分左右，直到每一组的i = j 为止*/
}
```
