分治法
---
> `定义`: `将一个难以直接解决的大问题，合理分割成一些规模较小的相同问题，以便各个击破，这个策略就叫分而治之`<br/>
---
> 直接或间接地调用自身的算法称为递归算法。 用函数自身给出定义的函数称为递归函数 分治与递归像一对孪生兄弟，经常同时应用在 算法设计之中，并由此产生许多高效算法。<br/>

---
最优子结构性质:`如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）`

平衡子问题:`种使子问题规模大致相等的做法是出自一种平衡 (balancing)子问题的思想`


#### 分治法的两个启发式规则: `独立子问题`,`平衡子问题`
#### 递归函数的两个要素
    * 边界条件
    * 递归方程
#### 分治策略
* 1.**分解**: `将原始问题划分或者归结为规模较小的自问题`  <br/>
* 2.**求解**:`迭代或递归求解每一个自问题`<br/>
* 3.**合并**:`将子问题的解综合得到原问题的解`<br/>
#### 注意原则
* 1.`子问题和原问题性质完全一样`
* 2.`子问题之间可以彼此独立地求解`
* 3.`递归停止子问题可直接求解`
* 4.`在用分治法设计算法时， 最好使子问题的规模大致相同`
----
**分治法**可以分为两个重要步骤：<br/>
* `自顶向下`：将问题不断分割成小的问题
* `自底而上`：将小问题解决来构建大问题的解。
### 算法例题
----
#### 1. 阶梯问题
一个阶梯有n个级，一个人要走完这个阶梯，一步可以走一级或两级。问：共有多少个方案？
> 本质上就是斐波拉基数列<br/>
`一个台阶 只有一种走法`<br/>
`两个台阶 有两种走法  走两步 走一步`<br/>
`三个台阶 可以是从第二个台阶走一步跨两级 也可以是从第一个台阶走两步一步一级 所有为第一层的走法加上到第二层的走法`<br/>
`四个个台阶 可以是从第二个台阶走一步跨两级 也可以是从第一个台阶走两步 所有为第二层的走法加上到第三层的走法`<br/>
...  `类推`<br/>
`斐波那契数列,每次只能走1或2级，所以到第十层的走法总和是到第8层的走法加上到第9层的走法`<br/>
#### Jva语言代码
```c
public static int step(int s)
{
    if( s <= 0 )
        return 0;
    if( s <= 2 )
        return s;
    return step( s - 1 ) + step( s - 2 );
}
```
----
#### 2. 排列问题
给定n个字符{r1,r2,…,rn}，要求生成这n个字符的全排序
> 全排列的问题本质是一种交换 例如 1，2两个字符 全排列 1与1交换 得到1,2 1与2交换得到 2,1 <br/>
  `1,2,3` 得到全排列的过程 1与1本身交互 得到`1,2,3`然后1与2交换 得到` 2,1,3` 然后1与3交换 得到`3,2,1` 这样得到了 `1,2,3` / `2,1,3` / `3,2,1 `<br/>
  然后 再交换 对于`1,2,3` 进行2与2本身交换 得到`1,2,3` 然后2.3交换 得到1,3,2 类似的 2,1,3可以得到`2,1,3` /`2,3,1` `3.2.1`可以得到 `3，2，1`和`3,1,2` 然后最后一位不用交换  即使交换也是得到本身

#### Java代码
```Java
public static void Perm(char list[],int k,int m) {
	if(k==m) {
		//输出一个排列结果
		for(char val : list) {
			System.out.print(val);
		}System.out.println();
	}else {
		for(int i=k;i<m;i++) {
			Swap(list,i,k);
			Perm(list, k+1, m);
			Swap(list, i, k);
		}
	}	
}
public static void Swap(char list[],int i,int j) {
	char val=list[i];
	list[i]=list[j];
	list[j]=val;
}
```


----
#### 3. 二路归并排序 
> `二路归并排序是采用的分而治之的思想。将一个待排序的序列分成两个序列，分别对这两个序列排序。而对于这两个序列排序的方式也是还之前一
样，将这两个序列分别分成两个序列分别排序。一直这样分割下去，知道序列中没有元素或者已有一个元素为止。因为没有元素的序列和只有一个
元素的序列定是一个有序的序列，所以相当于将这个序列排序完毕，向上返回。返回的过程中做的最重要的一件事就是将两个有序的序列合并成一
个有序的序列。`

二路归并排序的最好,最坏,和平均时间复杂度为`O(nlgn)`;是一种稳定的排序 <br/>

#### Java代码

``` C#
public static void Sort(int[] a, int f, int e)
{
    if (f < e)
    {
        int mid = (f + e) / 2;
        Sort(a, f, mid);
        Sort(a, mid + 1, e);
        MergeMethid(a, f, mid, e);
    }
}
```

``` c#
private static void MergeMethid(int[] a, int f, int mid, int e)
{
    int[] t = new int[e - f + 1];
    int m = f, n = mid + 1, k = 0;
    while(n <= e && m <= mid)
    {
        if (a[m] > a[n]) t[k++] = a[n++];
        else t[k++] = a[m++];
    }
    while (n < e + 1) t[k++] = a[n++];
    while (m < mid + 1) t[k++] = a[m++];
    for (k = 0, m = f; m < e + 1; k++, m++) a[m] = t[k];
}
```
参考: [`其他语言代码`](https://baike.baidu.com/item/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/1639015?fr=aladdin)
#### 4. 快速排序 
> `快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。`
#### 特性
* `时间复杂度`:`O(nlogn)`

----
#### C语言代码
``` c

```
#### 5. 整数划分问题 
> `指把一个正整数n写成多个大于等于1且小于等于其本身的整数的和，则其中各加数所构成的集合为n的一个划分`

把一个正整数m分成n个正整数的和，有多少种分法？
```
例如5的划分：
5
(1) 5;
(2) 4+1;
(3) 3+2 3+1+1;
(4) 2+2+1 2+1+1+1+1;
(5) 1+1+1+1+1;
```
解析:`将一个整数划分 的问题归结为一个再对一个数的划分最大数不超过几的问题 例如p(5,1) 只有一种划分1+1+1+1+1 p(5,2) 有三种划分 2+2+1 / 1+1+1+2 / 1+1+1+1+1`
* `p(n,1) 最大整数为1 返回1 只有一种划分 p(n,m) 只要有一个等于1 就换回1`
* `p(n,m) m>n 等同于 p(n，n)`
* `p(n,n) 等于 1+p(n,n-1) 划分里面包含n只有一种`
* `p(n,m) n>m>1 此时 p(n,m)=p(n,m-1) +p(n-m,m)  此时可以归结为 划分中最大整数 是m 或者不是m 两个问题 如果是m 那么就如同 p(5,2)如果最大数为2 那么剩下的划分为 2+ 1+1+1 或者2+ 2+1`
#### Java代码
```java
public  static int q(int n,int m){
    if(n<1||m<1) return 0;
    if(n==1||m==1) return 1;
    if(n<m) return q(n,n);
    if (n==m) return 1+q(n,n-1);
    return q(n,m-1)+q(n-m,m);
} 
```
#### 5. 棋盘覆盖问题
棋盘覆盖问题。有一个2k∗2k的方格棋盘，恰有一个方格是黑色的，其他为白色。你的任务是用包含3个方格的L型牌覆盖所有白色方格。黑色方格不能被覆盖，且任意一个白色方格不能同时被两个或更多牌覆盖。
#### 特.性
* 时间复杂度:O（4的k次方） 
#### 适用条件
* 该问题缩小到一定程度就可以容易地解决
* 该问题可以分解成若干个规模较小的相同问题,即该问题具有最优子结构性质
* 子问题的解可以合并为该问题的解
* 子问题的求解相互独立
