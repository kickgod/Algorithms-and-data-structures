分治法
---
> `定义`: `将一个难以直接解决的大问题，合理分割成一些规模较小的相同问题，以便各个击破，这个策略就叫分而治之`<br/>
---
#### 分治策略
* 1.`将原始问题划分或者归结为规模较小的自问题`<br/>
* 2.`迭代或递归求解每一个自问题`<br/>
* 3.`将子问题的解综合得到原问题的解`<br/>
#### 注意原则
* 1.`子问题和原问题性质完全一样`
* 2.`子问题之间可以彼此独立地求解`
* 3.`递归停止子问题可直接求解`
----
**分治法**可以分为两个重要步骤：<br/>
* `自顶向下`：将问题不断分割成小的问题
* `自底而上`：将小问题解决来构建大问题的解。
### 例如
#### 二路归并排序 
> `二路归并排序是采用的分而治之的思想。将一个待排序的序列分成两个序列，分别对这两个序列排序。而对于这两个序列排序的方式也是还之前一
样，将这两个序列分别分成两个序列分别排序。一直这样分割下去，知道序列中没有元素或者已有一个元素为止。因为没有元素的序列和只有一个
元素的序列定是一个有序的序列，所以相当于将这个序列排序完毕，向上返回。返回的过程中做的最重要的一件事就是将两个有序的序列合并成一
个有序的序列。`

二路归并排序的最好,最坏,和平均时间复杂度为`O(nlgn)`;是一种稳定的排序 <br/>

#### 代码

``` C++
#include<iostream>
using namespace std;

void Merge(int data[], int low, int mid, int high)
{
    int i = low, j = mid + 1, k = 0;   
    int *temp = new int[high - low + 1];      //temp数组暂存合并的有序序列
    
    if(!temp)                                 //内存分配失败 
    {
        cout<<"ERROR!";
        return;
    }
    
    while(i <= mid && j <= high)             //顺序选取两个有序区的较小元素，存储到t数组中
    {
        if(data[i] <= data[j])                 //较小的先存入temp中
            temp[k++] = data[i++];
        else
            temp[k++] = data[j++];
    }
    
    while(i <= mid)                          //若比较完之后，第一个有序区仍有剩余，则直接复制到t数组中
        temp[k++] = data[i++];
    while(j <= high)                         //同上
        temp[k++] = data[j++];
    for(i=low, k=0; i <= high; i++, k++)     //将排好序的存回data中low到high这区间 
        data[i] = temp[k];
    delete [ ]temp;                          //删除指针，由于指向的是数组，必须用delete [] 
}
```

``` c++
void MergeSort(int data[], int low, int high) 
{                                            //用递归应用二路归并函数实现排序——分治法
    if(low<high)                             //（是if，不是while！，且不含等号！否则死循环！）
    {
        int mid = (low + high) / 2;
        MergeSort(data, low, mid);
        MergeSort(data, mid + 1, high);
        Merge(data, low, mid, high);
    }
}
```
``` c++
int main()
{
    int x[ ] = {0, 5, 33, 1, 8, 7, 23, 3};
    MergeSort(x, 0, 7);
    for(int i = 0; i < 8; i++)
        cout<<x[i]<<" ";
    return 0;
}
```
